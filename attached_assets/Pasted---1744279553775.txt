Отличный выбор! Иерархическая классификация действительно хорошо подходит для вашей задачи. Давайте разберем, как именно можно реализовать эту стратегию с двумя моделями RWKV.

### Подход с двумя моделями RWKV

#### Модель 1: Базовые действия (уже существует)
- **Входные данные**: Все ваши текущие признаки (карты, размеры стеков, позиция, история и т.д.)
- **Выходные данные**: Вероятности 5 базовых действий [Fold, Check, Call, Bet, Raise]
- **Использование**: Определяет основное действие игрока

#### Модель 2: Размеры ставок (новая)
- **Входные данные**: 
  - Те же признаки, что и для Модели 1
  - Дополнительно: информация о том, что предсказано действие Bet или Raise
- **Выходные данные**: Вероятности размеров ставок [Small (50%), Medium (78%), Big (100%+)]
- **Использование**: Активируется только когда Модель 1 предсказывает Bet или Raise

### Преимущества этого подхода

1. **Решение проблемы дисбаланса**: 
   - Вторая модель обучается только на подмножестве данных (где есть Bet или Raise)
   - Все классы во второй модели примерно одинаково представлены

2. **Фокусированное обучение**:
   - Каждая модель решает свою конкретную задачу
   - Вторая модель может сфокусироваться на нюансах, определяющих размер ставки

3. **Реиспользование существующей модели**:
   - Ваша текущая модель RWKV1 остается без изменений
   - Не нужно переобучать первую модель

### Реализация

Для реализации этой стратегии:

1. **Подготовка данных для второй модели**:
   ```python
   # Отфильтровать только записи, где действие - Bet или Raise
   bet_raise_data = data[data['action'].isin(['Bet', 'Raise'])]
   
   # Добавить целевую переменную - размер ставки
   bet_raise_data['bet_size_category'] = bet_raise_data['bet_size'].apply(
       lambda x: 'Small' if x <= 0.65 else 'Medium' if x <= 0.9 else 'Big'
   )
   ```

2. **Адаптация архитектуры RWKV**:
   - Сохранить ту же архитектуру, что и у первой модели
   - Изменить выходной слой на 3 класса вместо 5
   - Возможно, увеличить размерность внутренних слоев, так как задача может требовать более детального анализа

3. **Обучение второй модели**:
   - Использовать только данные с Bet/Raise
   - Возможно увеличить количество эпох, так как данных будет меньше

4. **Интеграция моделей**:
   ```python
   def predict_action_and_size(features):
       # Предсказываем базовое действие
       base_action_probs = model1.predict(features)
       base_action = np.argmax(base_action_probs)
       
       # Если Bet или Raise (индексы 3 или 4), предсказываем размер
       if base_action in [3, 4]:  # Bet или Raise
           size_probs = model2.predict(features)
           size_category = np.argmax(size_probs)
           return base_action, size_category
       else:
           return base_action, None
   ```

### Возможные улучшения

1. **Совместное обучение моделей**:
   - После начального обучения обеих моделей можно настроить их веса совместно
   - Это может улучшить общую точность системы

2. **Добавление специфических признаков для второй модели**:
   - SPR (Stack-to-Pot Ratio) - особенно важен для определения размера ставки
   - Текстура доски (монотонная, связанная и т.д.)
   - История размеров ставок оппонента

3. **Мягкая иерархия**:
   - Вместо жесткого решения (если Bet, то спрашиваем вторую модель)
   - Можно взвесить предсказания второй модели вероятностями Bet/Raise из первой

### Оценка качества

Для оценки второй модели рекомендую использовать:
1. Матрицу ошибок для категорий размеров ставок
2. Точность по каждой категории (precision, recall, F1)
3. Общую взвешенную метрику для всей системы

Такой подход с двумя моделями должен хорошо справиться с проблемой дисбаланса классов и при этом сохранить преимущества вашей существующей модели RWKV1.